
#### Revisit WEEK4 SLOG on stacks  

Although a simple stack was introduced in Week4 SLOG, much more could be derived from from it. Notably, one of its variants is called __call stack__, where information regarding subroutines of a program is stored. It is usually hidden in higher level programming languages. The most powerful usage of stack in storing subroutine functions lies in its ability to keep track of the point to which the subroutines should `return`. Usually, _call instructions_ and _return address_ are pushed to the stack whenever functions are called and removed whenever functions are returned. In this process, the control is transferred as addresses are pushed or pulled. A stack with a given function can be called a _thread_, analogously linking the routines that are specified in the program. However, stacks are given limited amount of address spaces for storage, programs that exceed such limit will reach a state termed as _stack overflow_. This is the infamous error that always arises should anyone implement an _infinite loop_ or _deep recursions_. In a general scope, call stacks provide much more than just a storage for _return addresses_. It is able to store local variables, pass parameters from routines to routines, acting as an interface cross subroutines.  
