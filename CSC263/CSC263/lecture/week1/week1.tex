\documentclass[11pt]{article}
\input{/Users/markwang/.preamble}

% begin document
\begin{document}

\marginnote{Jan 5, 2017}

\section{Course Overview}


\textbf{Abstract Data Type (ADT)} a set of objects and operations on them.

\begin{example}
  Object: integers; Operations: +, -, x, /
\end{example}

\begin{example}
  Object: sequences of other objects; Operations: PUSH, POP, ISEMPTY along with description and effects of each operation
\end{example}

\begin{rem}
  ADT describes \textbf{what} are the objects. Data structure describes \textbf{how} ADT's are implemented.
  \begin{itemize}
    \item array is an implementation of stack
    \item linked list implementation of stack
  \end{itemize}
\end{rem}

$ $\\
\textbf{Complexity Analysis}

\begin{rem}
  Used to compare different data structures. There are several categories of complexity, i.e. running time complexity and space complexity.
\end{rem}

$ $\\
\textbf{Time Complexity}

\begin{rem}
  Represents the \textit{abstract running time}, independent of hardware, programming language, etc. Time complexity is a function with the number of steps depending on the size of input. (Note that size is measured informally here as size of input. The true measure of input size would involve the number of bits stored in memory)
\end{rem}

\begin{example}
  \textsc{LinkedSearch(L, k)}
\end{example}


\begin{algorithm}[H]
    \label{LinkedSearch Algorithm}
    \caption{LinkedSearch}
    \DontPrintSemicolon
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    \SetKwFunction{ls}{LinkedSearch}

    \Fn{\ls$(L, k)$}{
        \KwIn{$A$ is an array of objects}
        \KwOut{Returns the index of $k$ in $L$}

        $z = l.head$ \\
        \While{$z\neq None \land z.key \neq k$}{
          $z = z.next$
        }
        \Return $z$
    }
\end{algorithm}

$ $\\
This algorithm runs in $\mathcal{O}(n)$. For any input $n$, the number of steps taken depends on where $k$ is in $L$. We are primarily intersted in the worst case scenario. We can also calculate the average running time.


\begin{rem}
  Difference between worst-case / best-case and upper-bound $\mathcal{O}$ / lower-bound $\Omega$. \\
  \textbf{Asymmetry of bounds} Proving upper bound on the worst case tells us that no instance regardless of input takes more step than the upper bound. Proving lower bound on the worst case tells us that at least one instance regardless of input takes longer time than the lower bound in the worst case. This is flipped for best-case.
\end{rem}


\begin{figure}[h!]
  \centering
  \begin{forest}
    [9
      [17
        [7
          [4]
          [9]
        ]
        [12]
      ]
      [5
        [7]
        [3]
      ]
    ]
  \end{forest}
  \hspace{2cm}
  \begin{forest}
    [17
      [9
        [7
          [4]
          [3]
        ]
        [3]
      ]
      [12
        [9]
        [5]
      ]
    ]
  \end{forest}
  \caption*{A regular full binary tree and a heap}
\end{figure}

\begin{defn*}
  \textbf{Priority Queue} \textit{(ADT)} \\
  A queue (ADT) where each element has a "priority". Operations include
  \begin{itemize}
    \item  \textsc{Insert(S, x)}: adds $x$ to priority queue $S$. Assume that $x.priority$.
    \item \textsc{Max(S)}: return an item with maximum priority in priority queue $S$
    \item \textsc{ExtractMax(S)}: removes and return an item with maximum priority from $S$
  \end{itemize}

  \begin{rem}
    Items with higher priority come out first.
  \end{rem}
\end{defn*}



$ $\\
Possible data structure
\begin{itemize}
  \item Unsorted array. \textsc{Insert(S, x)} takes $\mathcal{O}(1)$; However \textsc{Max(S)} and \textsc{ExtractMax(S)} takes  $\mathcal{O}(n)$.
  \item Sorted array. \textsc{Max(S)} and \textsc{ExtractMax(S)} takes $\mathcal{O}(\log n)$ with binary search algorithm; However \textsc{Insert(S, x)} takes $\mathcal{O}(n)$ since we have to shift all subsequent item in array.
\end{itemize}

$ $\\
\begin{defn*}
  \textbf{Heap} \textit{(data structure)}
  is a full binary tree following heap order, The heap order indicates that each node's priority is greater than or equal to priorities of its children.
  \begin{rem}
    Every path from root to leave is in decreasing order. Note that however
  \end{rem}

\end{defn*}


\begin{defn*}
  A full binary tree is a tree in which every node other than the leaves has two children.
\end{defn*}


\begin{itemize}
  \item \textsc{Insert(S, x)}: Insertion has to maintain both shape of the tree and order. Since shape is difficult to maintain. We add $x$ to the correct leaf position for a full tree. Then we swap $x$'s position with its parent as long as $x$ has a higher priority than its parent. We call it \textit{bubble up} the new value to restore order. This procedure takes $\Theta(\log n)$

\begin{figure}[!h]
  \centering
  \begin{forest}
    [17
      [9
        [7
          [4]
          [3]
        ]
        [3
          [13[blue]]
          [,phantom]
        ]
      ]
      [12
        [9]
        [5]
      ]
    ]
  \end{forest}
  \hspace{1cm}
  \begin{forest}
    [17
      [9
        [7
          [4]
          [3]
        ]
        [13
          [3]
          [,phantom]
        ]
      ]
      [12
        [9]
        [5]
      ]
    ]
  \end{forest}
  \hspace{1cm}
  \begin{forest}
    [17
      [13
        [7
          [4]
          [3]
        ]
        [9
          [3]
          [,phantom]
        ]
      ]
      [12
        [9]
        [5]
      ]
    ]
  \end{forest}
\end{figure}





  \item \textsc{Max(S)}: takes $\mathcal{O}(1)$ because the root element has the highest priority.
  \item \textsc{ExtractMax(S)}: We first remove the root of the tree and move the rightmost element at the bottom-most level to the root. Now we then swap the element with the child with the larger priority until order is restored. This procedure takes $\Theta(\log n)$
\end{itemize}


\section*{2 Binomial Heaps}

\begin{defn*}
  \textbf{Mergeable Heaps} (ADT) collection of items with
\end{defn*}


\textsc{UNION}$(H_1, H_2)$:


\end{document}
