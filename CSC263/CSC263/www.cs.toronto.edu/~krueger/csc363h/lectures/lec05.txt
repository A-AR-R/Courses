===========================================================================
CSC 363H                Lecture Summary for Week  5             Summer 2006
===========================================================================

------------
Reducibility
------------

HALT_TM = { <M,w> | M is a TM that halts on input w } is undecidable.
Proof by contradiction: done in tutorial.

Each of the following language is undecidable:

 -  E_TM = { <M> | M is a TM such that L(M) = {} }:
    Assume R decides E_TM, and construct S as follows:
    S = "On input <M,w>:
     -  Compute <Q>, the description of the following TM:
        Q = "On input x:
         -  Ignore x and simulate M on w;
            accept if M accepts; reject if M rejects."
     -  Run R on input <Q> and do the opposite
        (if R accepts, reject; if R rejects, accept)."
    Then S accepts <M,w> iff R rejects <Q> iff L(Q) != {} iff L(Q) = S^*
    (by construction, either Q accepts all strings or Q accepts no string)
    iff M accepts w.  Moreover, S always halts because R always halts.
    Hence, S decides A_TM, a contradiction!

 -  EQ_TM = { <M_1,M_2> | M_1 and M_2 are TMs such that L(M_1) = L(M_2) }:
    Assume R decides EQ_TM and construct S as follows:
    S = "On input <M>:
     -  Compute <M'>, the description of the following TM:
        M' = "On input x: reject."
     -  Run R on input <M,M'> and do the same."
    Then S decides E_TM, a contradiction.

 -  REGULAR_TM = { <M> | M is a TM such that L(M) is regular }:
    Exercise: try this one (use A_TM as the other language).
    The solution is in the textbook.

--------------------
Mapping Reducibility
--------------------

General structure of proof of undecidability of some language A:

    Assume R decides A.
    Construct S to decide B (some undecidable language):
    S = "On input x:
     -  Compute y such that y in A iff x in B.
     -  Run R on y and do the same."
    Then, S decides B because y in A iff x in B.

Since structure always the same, concentrate on "core" part: construction
of y from x such that y in A iff x in B.

Definition 5.20: "mapping reducibility"; "reduction".

Example 5.26: E_TM <=m EQ_TM.
    Given <M>, construct <M1,M2> as follows:
        M1 = M, M2 = fixed TM that rejects all inputs
    Clearly, this is computable (copy string, append constant string).
    Moreover, since L(M1) = L(M) and L(M2) = {}, <M> in E_TM iff L(M) = {}
    iff L(M1) = L(M2) iff <M1,M2> in EQ_TM.

Theorem 5.22:
    If A <=m B and B is decidable, then A is decidable.
Proof:  (see textbook -- done in lecture)

Theorem 5.28:
    If A <=m B and B is recognizable, then A is recognizable.
Proof:  (see textbook -- done in lecture)

Corollary 5.23:
    If A <=m B and A is undecidable, then B is undecidable.

Corollary 5.29:
    If A <=m B and A is unrecognizable, then B is unrecognizable.

Properties:

 -  A <=m B iff A^C <=m B^C.  (Straight from definition, since statement
    "w in A iff f(w) in B" is equivalent to "w not in A iff f(w) not in B"
    and "w not in A" = "w in A^C".)

 -  If A <=m B and B <=m C, then A <=m C.  (Easy exercise, based on
    function composition: if f,g computable, then g(f()) computable.)

Examples:

 -  A_TM <=m E_TM^C but A_TM not <=m E_TM (in tutorial).

 -  A_TM <=m HALT_TM: different from "informal" reduction used to prove
    HALT_TM undecidable.
    Given <M,w>, construct <M',w'> such that M accepts w (<M,w> in A_TM)
    iff M' halts on w' (<M',w'> in HALT_TM), as follows:
        M' = M except replace all transitions to q_reject with transition
        to state q_new, then add transitions from q_new to q_new for each
        input symbol (q_new is deliberate infinite loop)
        w' = w
    Clearly, this is computable.
    Moreover, if M accepts w, then M' accepts w'; if M rejects w, then M'
    loops on w'; if M loops on w, then M' loops on w', i.e., M accepts w
    iff M' halts on w', as desired.

