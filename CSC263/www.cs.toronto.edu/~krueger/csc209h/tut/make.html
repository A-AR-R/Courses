<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Notes on Makefiles</title>
  </head>

  <body bgcolor="#FFFFFF">
    <h1>Notes on Makefiles</h1>

<p> Makefiles contain a several types of elements: variable declarations,
	dependency rules, commands, and comments.  

<p> Variable declarations look like Bourne shell variable assignments.  A
variable usage starts with $ and has parentheses around the variable
	  name. In the example below, the line <tt>CC = gcc</tt> sets the
	  variable <tt>CC</tt>.  The variable is later used as <tt>$(CC)</tt>.

<p> Dependency rules have the following structure:
	  <pre>
       &lt;target> : &lt;dependencies>
       &lt;tab>&lt;command>
	</pre>
The target is the name of the dependency rule. The target is followed by a
	colon, and a list of the files or targets that this rule depends
	on. The line following the target line begins with a tab, and contains
	the command to be run to evaluate the rule.

<p> <em>What does it mean for a rule to "depend on" a file or target?</em>
	  <br> The rule will be evaluated if any of the files or targets are
	  newer than the result of the rule evaluation.  For example, the rule
	  beginning with the target <tt>main</tt> will be evaluated if any of
	  the object files are newer than the executable <tt>main</tt>.  These
	  dependencies are recursively evaluated, so a rule associated with one
	  of the object files, will be evaluated if the source file is newer
	  than the object file.  If "d.c" is newer than "d.o" then when we run
	  "make main", the recursive dependency analysis will cause the rule
	  that compiles "d.o" to be evaluated producing a new object file. Then 
	  the "main" rule will be evaluated because "d.o" is newer than main.

<p> One problem with the main rule as we have specified it, is that if we
	  modify a ".h" file, the rule will not be evaluated because the ".h"
	  files are not in the dependency list.  We have two options to handle
	  this. The first is to put the ".h" files into the dependency list.
	  The second is to include a rule that will run the program
	  "makedepend" on the sources.  "makedepend" looks at all the source
	  files and parses out the "include" files and produces a dependency
	  list. After we run "makedepend", the target main will be evaluated if 
	  a ".h" file is newer than the executable.



<pre>
CC = gcc
CFLAGS = -g -Wall

SRCS = main.c a.c b.c d.c
HDRS = a.h b.h d.h
OBJS = main.o a.o b.o d.o

# The first rule is the one that is run when we type main
# This rule contains the variable $@ which is the name of the target
main : $(OBJS)
	$(CC) $(CFLAGS) -o $@ $(OBJS)

# This is a special kind of rule that says how to turn .c files into .o files
# The variable $< refers to the dependency rule that was matched by the
# rule. (In this case the name of the source file.)
.c.o : 
	$(CC) -c $(CFLAGS) $<

depend:
	makedepend $(SRCS)

print:
	more $(HDRS) $(SRCS) | enscript -2r -p listing.ps

# DO NOT DELETE (depend needs it)
</pre>

The source code files are 
<ul>
<li> Header files: <a href="make-ex/a.h">a.h</a>, <a
		  href="make-ex/b.h">b.h</a>, <a href="make-ex/d.h">d.h</a>  
<li> Source files: <a href="make-ex/a.c">a.c</a>, <a
		  href="make-ex/b.c">b.c</a>, <a href="make-ex/d.c">d.c</a>, <a
		  href="make-ex/main.c">main.c</a> 
</ul>


<p>Another sample makefile, prepared by Professor Clarke and modified slightly
by me, can be found <a href="clarkemake">here</a>
    <hr>
<!-- Created: Tue Mar 13 23:27:03 EST 2001 -->
<!-- hhmts start -->
Last modified: Wed Mar 14 10:21:30 EST 2001
<!-- hhmts end -->
  </body>
</html>
