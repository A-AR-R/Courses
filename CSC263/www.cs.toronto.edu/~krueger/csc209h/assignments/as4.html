<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html><head><title>CSC 209H Summer 2006</title></head>


<body bgcolor="#fbfbf0" link="#0000aa" vlink="#602000">

<h1>CSC 209H: Assignment 4</h1>

<!--<p><b>Grading:</b> 20 marks.</p>-->

<p><b>Weight:</b> 10% of course grade.</p>

<p><b>Due date:</b> 10:00 p.m. Friday August 11</p>

<hr>
<h2>Introduction</h2>

<p>
In this assignment, you will be writing a simple client-server casino system.
You will be writing two C programs, one server and one client, that
implement a basic protocol allowing multiple users to play blackjack
over the Internet. The rules for blackjack (including our simplifications)
are explained in the assignment 3 specifications.
</p>

<hr>

<h2>bjserver</h2>

<p>
Your server will be called <tt>bjserver</tt>. 
It will act as a blackjack dealer, dealing a game of blackjack for up
to 6 currently connected players.
</p>

<p>
Your program should support being run in the following manner:
</p>

<p>
<tt>$ bjserver </tt> <i>[numdecks]</i>
</p>

<p>
The optional <i>numdecks</i> indicates the number of decks to use in the
game, and must be between 1 and 8 inclusive. You should default to using
6 decks if the <i>numdecks</i> parameter is absent.
</p>

<p>
Your program will listen on the
specified port for client connections, 
and while clients are connected, your server will deal rounds of
blackjack, using messages according to the protocol below.
Each message that is expressed as a string is terminated with a null
<tt>'\0'</tt> character.
</p>

<ul>
<li>Name: The first thing a client sends is a name to be identified by.
The name is a string consisting of between 1 and 15 alphanumeric or
punctuation characters (no whitespace). The string is terminated by
a null byte <tt>'\0'</tt>. The server will reply with a short integer
(in network byte order) indicating the number of decks in use in the game.
</ul>

<p>
Once a client connects, the client may join play in the next round.
Play proceeds according to the rules established in the Assignment 3
specification: in particular, cards are shuffled between rounds when there
is less than one deck remaining to play with, no splitting or double-downs,
blackjacks are paid out at 3:2 odds rounded down ot an integer.
The following protocol indicates the comminication between the server
and the clients during each round of play.
</p>

<ul>
<li>Shuffled:
If the server has just shuffled the cards, the server will send one
byte consisting of the character <tt>'0'</tt> to indicate this event.
If the cards were not just shuffled, no byte is sent.

<li>Bet:
A long integer bet is sent from the client to the server.
Four bytes are sent expressing the integer in network-byte order.
The bet may be any number between 1 and 1000 inclusive.<br>
If a client disconnects before a bet is sent, the client should lose
its place at the "table" and not be involved in this round of play.

<li>Players:
The server sends information about the current set of players to each
active client.
This information is sent as a string, with fields spearated by spaces,
as follows:<br>
<tt><i>nplayers</i> <i>yournumber</i> <i>names...</i>\0</tt><br>
The <i>nplayers</i> field is the number of players in this hand, an integer
expressed as a string.
The <i>yournumber</i> field is which number this client is in the list of
players.
The <i>names...</i> is the list of the names of the 
<i>nplayers</i> players, separated by spaces.

<li>Hands:
The server sends a list of all the hands to each client.
The format is:<br>
<i>dealer_cards player1_cards ... playerN_cards</i> <tt>\0</tt><br>
The cards in each hand are listed separated by commas; the hands are
separated by spaces.
A card is represented in the same format as on Assignment 3 (two
characters indicating rank and suit).

<li>Choice:
Each client indicates whether to hit or stand by sending one byte:
<tt>'H'</tt> for hit, and <tt>'S'</tt> for stand.<br>
If the client's hand totals more than 21 (the client busted), no byte
is sent and the server considers the hand complete.<br>
If the client chooses to hit, the dealer deals the player one
additional card, and sends the list of cards to all clients (as
explained above).<br>
If the client chooses to stand, the server considers the hand complete.<br>
If a client disconnects and its hand is not complete, the dealer
should treat the hand as though the client chose to stand.

<li>Result:
Once all hands are considered complete, the dealer plays its hand.
It should draw cards until the dealer's hand totals 17 or more.
Once the dealer's hand is complete, the server sends the list of cards
to all clients.

<li>Winnings:
Finally, the dealer sends <i>nplayers</i> signed long integers,
indicating the total +/- winnings of each of the players.
</ul>


<p>
Normally hands are played sequentially. Over the Internet, though,
network delays might slow the play, and one slow player would make the
other players impatient.
To speed play, the server should allow players to play their hands in
parallel. If a client sends a hit message, the server should service
that request fairly: it should not have to wait for another idle
client to send a message before it receives a new card.
(That is, use the <tt>select</tt> function.)
</p>

<hr>

<h2>bjclient</h2>

<p>
The second C program you will write is a client program that will interface
with your server program via the protocol described above.
</p>

<p>
Your program should support being run in the following manner:
</p>

<p>
<tt>$ bjclient </tt> <i>host [username]</i>
</p>

<p>
<i>host</i> is the name or IP address of the server to connect to,
and is required.<br>
<i>username</i> is the name to be used for the connection. If
<i>username</i> is not specified, the value of the environment variable
<tt>USER</tt> should be used. If the <tt>USER</tt> variable is not
set, use some resonable preset default string.
</p>

<p>
Your client program will connect to the server, introducing itself
by sending a username, and reporting whether the connection is
successful or denied. It will then report the number of decks in use
on the server, and then allow the user to play.
</p>

<p>
For each round of play, your client program should prompt for the user
to enter a bet amount, which is then sent to the server (according to
the protocol explained above). If the cards have just been shuffled,
it should be reported to the user.
Within a round, each time the server
sends the listing of the hands, the client will display the known
hands to the user (in some reasonable format).
Until the hand is complete, the client should
accept a line from the user starting with an <tt>H</tt> or an
<tt>S</tt> (uppercase or lowercase) to indicate the user's choice of
hitting or standing.
</p>

<p>
If the user signals end of file instead of a bet, or bets zero, the
client should terminate the connection to the server and print a
message to the user indicating the final change in chips for the user.
</p>

<h3>Example</h3>

<p>
The following might be a sample execution of the program.
</p>

<pre>$ ./bjclient localhost me
Connected to 127.0.0.1 as me
Playing with 6 decks.
The cards have just been shuffled.
Bet? 10
Dealer       Richard      me
7C           3H,4H        4C,JD
(H)it or (S)tand? 
Dealer       Richard      me
7C           3H,4H,5C     4C,JD
(H)it or (S)tand? hit
Dealer       Richard      me
7C           3H,4H,5C     4C,JD,7D
(H)it or (S)tand? STAND
Dealer       Richard      me
7C           3H,4H,5C,JH  4C,JD,7D

Dealer       Richard      me
7C,KC        3H,4H,5C,JH  4C,JD,7D
  Winnings:  -5           10
You won! Your net winnings are now 10 chips.

Bet? 0
Disconnecting... You won 10 chips.
</pre>


<hr>

<h2>Hints, Tips and Clarifications</h2>

<ul>
<li>Start <b>now</b>! Get something simple working first, then
add functionality step by step to complete your programs.
</li>

<li>Use office
hours, TAs, and example programs from the website in addition to your
notes and textbooks to help get your assignment working correctly.
You can use any of the examples code (make sure you cite your source, though!).
</li>

<li>You may use any code that might be useful from your assignment 3,
the utility functions, or from the assignment 3 sample solution.
Make sure you add any additional file you use to your CVS repository!

<li>Your first step should be getting one client to connect with your server.
Then get it sending and responding to simple commands. Once one client is
working, try supporting multiple clients, then adding multiplexing with
<tt>select</tt>.
</li>

<li>You should use just one server process to allow communication
between clients.
</li>

<li>Example programs will be available in the
<tt>/u/csc209h/summer/pub/a4</tt> directory to help you get your programs
working and clarify expected behaviour.
</li>

<!--
<li>A sample chatserver might be running on <i>werewolf.cdf.utoronto.ca</i>
at TCP port 22428 (that's "2-CHAT") for you to use and test with.
</li>
-->

<li>The client should use <tt>select</tt> too.
</li>

<li>The <tt>getenv()</tt> function might be useful.
</li>

<li>You <b>must</b> check the return values from each system function
call and take appropriate action based on these return values (such as
printing an error message, exiting with error, closing a connection,
or continuing normally).
</li>

<li>For full marks, your source code must be
well-documented, follow good programming style, and be easily
understandable by the marker.</li>

<li>Which port should you use? We should be able to specify the port
at compile time, so that the person compiling your program need not
edit your code to change the port. In your code (possibly a header
file), include:
<pre>
#ifndef PORT
#define PORT 30000
#endif
</pre>
and set in your <tt>Makefile</tt> something like:
<pre>
PORT=10000
CFLAGS = -DPORT=$(PORT) -g -Wall
</pre>
The <tt>-D</tt> flag for the compiler tells gcc to define the symbol.
The "<tt>#ifndef</tt>" tells the compiler to only include the code if
the symbol hasn't already been defined.<br>
Now, if you type "<tt>make PORT=15000</tt>" the program will be
compiled with the macro PORT defined as 15000. If you type
"<tt>make</tt>" it will use the value defined for PORT in the
Makefile. Finally, if PORT is not defined on the compile line, it will
still have the value from your source code file. This method of
setting a port value will make it possible for us to test your code by
choosing a port value to compile your program with.
</ul>

<!--
<hr>

<h2>Learning Objectives</h2>
<ul>
<li>Creating and controlling processes under UNIX (<tt>fork</tt>,
<tt>wait</tt>, etc.).</li>
<li>Executing programs using C (<tt>exec</tt>).</li>
<li>Basic interprocess communication (pipes) in C.</li>
<li>Understanding file descriptors in UNIX.</li>
</ul>

-->
<hr>

<h2>What to hand in</h2>

<p>You will commit to the <code>a4</code> directory of your CSC209
repository the following files:</p>

<ul>
<li>Your C source files for <code>bjserver</code> and
<tt>bjclient</tt></li>
<li>Any additional files needed by your programs (header files, etc.)</li>
<li><code>Makefile</code>, containing commands to compile
your <tt>bjserver</tt> and <code>bjclient</code> simply by running
<tt>make</tt> and allows us you specify the port as mentioned above</li>
</ul>

<p>
You are strongly encouraged to take advantage of the version
control system and commit your work frequently so that you can keep
track of your progress.  Please note that perfectly fine (and even
recommended) that you keep any additional files related to this
assignment (such as files and scripts used for testing) under version
control. The markers will simply ignore such files.
</p>

<hr>

<table>
<tbody><tr>
<td>
<small>
<!--Copyright &#169;
Richard Krueger
<BR>
All rights reserved.
<BR>-->
<script language="JavaScript">
<!--
if (Date.parse(document.lastModified) != 0)
        document.write('<BR>Last update: ' + document.lastModified);
//-->
</script>
</small>
</td>
</tr>
</tbody></table>

</body></html>
