===========================================================================
CSC B63                 Lecture Summary for Week  2             Winter 2007
===========================================================================

--------------
Binomial Heaps
--------------

A binomial tree is a tree defined by the following recurrence:
 B_0 = a single node
 B_k = 2 copies of the binomial tree B_{k-1} linked by making one of the
       B_{k-1} trees the leftmost child of the root of the other

  B_0   B_1    B_2       B_3           B_4

   X    X      X          X             X
       /       /\        /|\        / |   | \
      X       X  X      X X X      X  X   X  X
             /         /\ |      /|\  /\  / 
             X        X X X     X X X X X X 
                     /         /\ /  /
                    X         X X X  X
                             /
                            X

Properties of a binomial tree B_k:
a) height = k
b) degree of root = k = max degree
c) number of nodes = 2^k
d) number of nodes at depth i = ( k ) = k "choose" i (the binomial coefficient)
                                ( i )
  (The length of a path from the root r to a node x is the _depth_ of x in T.)

    i.e. for B_3:
     depth    # of nodes
       0          1
       1          3
       2          3
       3          1

e) subtrees of the root (from the left) are B_{k-1}, B_{k-2}, ..., B_0

By properties a, b and c: 
If the number of nodes in a binomial tree is n, the height and 
the maximum degree = log_2 n

A _binomial_max-heap_ H is a collection of binomial trees satisfying the
following properties:
1) each binomial tree in H obeys the max-heap property (i.e. the priority
   of the parent >= priority of the children)
2) for any height h, there is at most one binomial tree in H with height 
   (or max degree) h

Therefore: If H has n nodes, then H contains at most floor(lg n) + 1
binomial trees (by c and 2)

Example:

 -> 10  ->  30  ->   100 
           / \      / | \
         12  25    9  14 29
         /        /\  /
        11       6  1 7 
                /
               5 

A binomial heap is stored as a linked list of binomial trees in (strictly)
increasing order of size.

Binomial heap operations:
-------------------------

maximum: find the maximum key
-------
algo: check each root for the maximum value
 worst-case running time is O(log n)
OR 
algo: keep a pointer to the element with the maximum key
 then return the key in O(1) time.

BINOMIAL-HEAP-UNION: uniting two binomial heaps into a single binomial heap 
-------------------

union algorithm uses BINOMIAL-HEAP-MERGE(H1, H2)

BINOMIAL-HEAP-MERGE(H1, H2): merges the linked lists of binomial trees
in H1 and H2 into a single linked list H of binomial trees that is sorted
by degree into increasing order.
There may be as many as two roots (but no more) of each degree.

and the union algorithm uses BINOMIAL-LINK(y, z)

BINOMIAL-LINK(y, z): links the B_{k-1} tree rooted at node y to the 
 B_{k-1} tree rooted at node z 
 -it makes z the parent of y. 
 -node z becomes the root of a B_k tree.


Example
-------
BINOMIAL-HEAP-UNION(H_1,H_2):

H_1 -> 6     ->   50                  H_2  ->   8   ->   20   ->  25 
                 /   \                                   /       /  \
                12   35                                12       17  19
                /                                               /
               2                                               10

Step 1: MERGE(H_1,H_2)

H_new -> 6   ->   8 ->   20    ->   50   ->  25
                         /         /   \    /  \
                        12        12   35  17  19
                                  /        /
                                 2        10

Step 2: Repeatedly use BINOMIAL-LINK to eliminate trees with the same degree:

H'_new -> 8 ->   20    ->   50   ->  25
          /      /         /   \    /  \
         6      12        12   35  17  19
                          /        /
                         2        10

H''_new ->   20      ->   50   ->  25
            /  \         /   \    /  \
           8   12       12   35  17  19
          /             /        / 
         6              2        10

H'''_new  ->   20      ->     50
              /  \          /  |  \
             8   12        25  12  35
            /             / \  /
           6             17 19 2 
                         /
                        10
Let n_1 be the number of nodes in H_1, and let n_2 be the number of nodes 
in H_2.
Let n = n_1 + n_2 be the number of nodes in the new list (H'''_new).

Step 1: MERGE(H_1,H_2) traverses the linked list of roots in H_1 and H_2.
Thus, it traverses at most log n_1 + log n_2 + 2 <= 2 log n + 2 nodes.
Thus, it takes O(log n) time in the worst case.

Step 2: Repeated use of BINOMIAL-LINK links at most log n_1 + log n_2 + 1
nodes together. Each BINOMIAL-LINK takes a constant amount of time (to update 
pointers).

Therefore, in the worst-case BINOMIAL-HEAP-UNION(H_1,H_2) takes O(log n) time.
  
INSERT
------
Create a new binomial heap H_2 containing a single node with the new
key and data. Union H_2 with the binomial heap H.

Running time: creating a new binomial heap with a single key reqires 
a constant amount of work. BINOMIAL-HEAP-UNION takes O(log n) time
in the worst-case.

Therefore, insert takes O(log n) time in the worst-case.

EXTRACT_MAX
-----------
Assume we have a pointer to the maximum key (otherwise, we would have to
find the maximum key first).

This pointers points to the root of some tree, say T.
Remove T from H, and let the new heap be H'.
Make a binomial heap H_2 by linking the children of the node with the maximum
 key in reverse order.
Union H' and H_2  
Return the maximum key

Example:                    | max_ptr
                            v 
H: ->  15  ->  18     ->   42
               /           / \
              12          26 23
                          /
                         16
H':  ->  15  ->  18           H_2: -> 23 -> 26
                 /                          /
                12                         16
Union(H',H_2):

H_new: -> 15   ->   23   ->  18  ->  26
                             /       /
                            12      16

H'_new: -> 23  ->  18  -> 26
           /       /      /
           15     12     16

H''_new: -> 23  -> 26
            /      / \
           15     18  16
                  /
                 12

Running time: 
 -Removing the maximum key takes constant time
 -Creating H_2 requires linking at most log n +1 nodes together  
 (since the degree of the node with the maximum key cannot be more 
 -Union takes O(log n) time in the worst-case

Therefore the total worst-case running time is O(log n)

Reading assignment: Chapter 19 - Binomial Min Heaps

