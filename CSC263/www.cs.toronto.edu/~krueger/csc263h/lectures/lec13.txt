===========================================================================
CSC 263                 Lecture Summary for Week 13               Fall 2007
===========================================================================

---------------------------------
Lower bounds: adversary arguments
---------------------------------

Let's find a lower bound on the worst-case time needed to compute the
following problem:

Is there an element that appears exactly 5 times and another element that
appears exactly 7 times in an n-element array of integers?

Do you know an algorithm to solve this problem?

Step 1: Sort all the elements
Step 2: Scan through the elements and count whether one element appears 5 
times and another appears 7 times.

The total worst-case time of this algorithm is in O(n log n)
So, either the lower bound on the worst-case time needed is Omega(n log n) or
it is something smaller.

Let's compute the lower bound using the decision tree method.
Fact 1: there are two possible solutions to this problem: yes and no
This implies: the number of leaves in the decision tree is at least 2 (there
may be duplicate leaves)

Fact 2: There are at most 3 outcomes (branches) at any level of the tree:
(<, =, >)

We can conclude: the decision tree for sorting has height at least log_3 2 
Since log_3 2 in Omega(1), we have a lower bound of Omega(1).

BUT, our lower and upper bounds don't match, and there doesn't seem to be
a constant time algorithm that solves this problem. What do we do?

Try a different method: Adversary method

Algorithm:
-asks a question
-tries to reduce choices as quickly as possible (i.e., tries to learn the input)

Adversary:
-answers questions such that at least one input is consistent with the answers
-tries to keep the legal set of inputs as big as possible (i.e., it ties
to make you do as much work as possible)

Example: The game "Guess Who?" I brought it in, and we talked about strategies
for winning the game if you didn't need to pick a particular person (i.e., 
input) at the beginning of the game.

We will use an adversary argument to solve the problem above.
Suppose the algorithm only take n-1 steps.
Then, it only reads n-1 spots in the array
The adversary let the algorithm read the following input:
x x x x x y y y y y y y . . . .  
The algorithm is correct, and saw 5 x's and 7 y's so it answers 'yes'.

BUT it did not see one of the input values

Case 1: The algorithm did not see a '.' value
If the adversary changes the input so the '.' becomes an 'x', we have:
x x x x x y y y y y y y . . x .
The algorithm behaves the same way, and answers incorrectly! 

Case 2: The algorithm did not see a 'x'
Case 3: The algorithm did not see a 'y'

For case each, we can change the input so that the algorithm answers 
incorrectly!

Therefore, we conclude that the algorithm needs to take at least n steps
=> a lower bound for the worst-case time for ANY algorithm to solve this 
problem is in Omega(n)

This is better than the Omega(1) lower bound from the decision tree method.

Something to think about: can we find an algorithm that takes linear time, or 
is our lower bound still too low?


